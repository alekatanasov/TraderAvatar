/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

package marketanalysis;



// imports:
import error.*;
import financialdata.*;
import indicators.*;
import java.math.BigDecimal;
import java.util.Vector;



/**
 * Technical analysis of the market conditions takes place in this class.
 *
 * @author Alexandar Atanasov
 */
public class MarketAnalyzer {
    // declare member variables:

    /** Instance of the ErrorHandler used for managing errors. */
    private static ErrorHandler eHandler;

    /** Shows if new standing order was generated. */
    private boolean newStandingOrder;

    /** Instance of the MarketRawData providing up to date information about the current market conditions. */
    private MarketRawData rawData;

    /** Instance of the MarketIntervalData class used by some indicatorsList. */
    private MarketIntervalData intervalData;

    /** List of indicatorsList to be used in the technical analysis of the market*/
    private Indicator indicators[];

    /** Instance of the AnalysisFormat class regulating and specifying various analysis aspects and details. */
    private AnalysisFormat analysisFormat;

    /** The last StandingOrder which was closed. */
    private StandingOrder lastClosedStandingOrder;

    /** The last valid standing order generated by this market analyzer. */
    private StandingOrder lastStandingOrder;

    /** The financial result produces from the lastly closed standing order. */
    private BigDecimal lastFinancialResult;

    /** */
    private StopLevelGenerator generator;
    
    // end of member variables declaration


    // initialization of static members:
    static {
        eHandler = new ErrorHandler("MarketAnalyzer");
    } // end of static variables initialization


    /**
     * Constructor.
     *
     * @param marketRawData Instance of the MarketRawData class for providing up to date information about the
     *                      market conditions. Providing null to this argument will generate error.
     * @param aFormat The analysis format which will be used for analyzing the market.
     * @param digitsAfterDot The number of digits after the dot in the price of the chosen security.
     */
    public MarketAnalyzer(MarketRawData marketRawData ,AnalysisFormat aFormat , int digitsAfterDot) {
        // set members
        setFinancialData(marketRawData);
        setAnalysisFormat(aFormat);
        setGenerator();
        setLastStandingOrder(null);
        setLastFinancialResult(BigDecimal.ZERO);
        setLastClosedStandingOrder(null);
        setNewStandingOrder(false);

    } // end of constructor


    /** 
     * Sets the rawData member.
     * 
     * @param data Instance of the MarketRawData class for providing up to date information about the 
     *             market conditions. Providing null to this argument will generate error.
     */
    private void setRawData(MarketRawData data) {
        // check for null pointer
        if(data == null) {
            // error ..
            eHandler.newError(ErrorType.NULL_ARGUMENT , "setRawData");

            // exit from method
            return;
        } // end if statement

        // set the rawData
        rawData = data;

    } // end of class setRawData


    /**
     * Sets the intervalData member.
     *
     * @param data Instance of the MarketRawData class for providing up to date information about the
     *             market conditions. Providing null to this argument will generate error.
     */
    private void setIntervalData(MarketRawData data) {
        // check for null pointer
        if(data == null) {
            // error ..
            eHandler.newError(ErrorType.NULL_ARGUMENT , "setIntervalData");

            // exit from method
            return;
        } // end of if statement

        // set the intervalData
        intervalData = new MarketIntervalData(data);

    } // end of method setIntervalData()


    /**
     * Sets the rawData and IntervalData members.
     * 
     * @param data Instance of the MarketRawData class containing up to date information about the
     *             market conditions. Providing null to this argument will generate error.
     */
    private void setFinancialData(MarketRawData data) {
        // set the data
        setRawData(data);
        setIntervalData(data);

    } // end of method setFinancialData


    /**
     * Sets the newStandingOrder member.
     * 
     * @param value The value to which the newStandingOrder will be set.
     */
    private void setNewStandingOrder(boolean value) {
        newStandingOrder = value;
    } // end of method


    /**
     *
     * @return
     */
    public boolean getNewStandingOrder() {
        // declare local variables:
        boolean result = newStandingOrder;
        // end of local variables declaration

        // nullify
        newStandingOrder = false;

        // return the result
        return result;
    } // end of method


    /**
     * Sets the lastClosedStandingOrder member.
     * 
     * @param order The last StandingOrder which was closed. If null is provided to this argument
     *              the lastClosedStandingOrder member will be set to null.
     */
    private void setLastClosedStandingOrder(StandingOrder order) {
        // set the lastClosedStandingOrder member
        lastClosedStandingOrder = order;
    } // end of method setLastClosedStandingOrder()


    /**
     * Returns the lastClosedStandingOrder member and than sets it to null.
     *
     * @return The last StandingOrder which was closed. In some cases this method may return null.
     */
    public StandingOrder getLastClosedStandingOrder() {
        // declare local variables:
        StandingOrder result = lastClosedStandingOrder;
        // end of local variables declaration


        //
        lastClosedStandingOrder = null;

        // return the result
        return result;

    } // end of method getLastClosedStandingOrder()


    /**
     * Sets the analysisFormat member.
     *
     * @param aFormat The analysis format which will be used in technical analysis of the market. If
     *                null is provided to this argument error will be generated.
     */
    public void setAnalysisFormat(AnalysisFormat aFormat) {
        // check for null pointer
        if( aFormat == null) {
            // error
            eHandler.newError(ErrorType.NULL_ARGUMENT, "setAFormat");

            // exit from method
            return;
        } // end of if statement

        // set the format
        analysisFormat = aFormat;

        // re initialize the indicatots
        initIndicators();

    } // end of method setAnalysisFormat()


    /**
     * Returns the analysisFormat member.
     *
     * @return The instance of the AnalysisFormat contained in this class.
     */
    public AnalysisFormat getAnalysisFormat() {
        return analysisFormat;
    } // end of method


    /**
     * Sets the generator member.
     */
    private void setGenerator() {
        if(rawData == null) {
            // error ..
            eHandler.newError(ErrorType.NULL_CLASS_MEMBER, "setGenerator" , "null rawData");

            // exit from method
            return;

        } // end of if statement

        // set the generator
        generator = new StopLevelGenerator(rawData.getDigitsAfterDot() ,
                                           new BigDecimal ("2.0") );

    } // end of method


    /**
     * Initializes and fills the indicatorsList array. The number and the type of indicatorsList which will be used
     * are taken from the analysisFormat member. This method will also initialize the indicator interpreters
     * via the initIndicatorInterpretators method.
     */
    private void initIndicators() {
        // declare local variables:
        IndicatorList indicatorsList[];
        Vector <String> indicatorParameters[];
        // end of local variables declaration


        // check for null format
        if(analysisFormat == null) {
            // error ..
            eHandler.newError(ErrorType.NULL_CLASS_MEMBER, "initIndicators" , "Null analysisFormat ");

            // exit from method
            return;
        } // end of if statement

        // get the indicatorsList
        indicatorsList = analysisFormat.getIndicators();

        // get the indicatorParameters
        indicatorParameters = analysisFormat.getIndicatorParameters();

        // check if there are no specifiedIndicators specified in the indicatorList
        if(indicatorsList == null) {
            // exit from method
            return;
        } // end of if statement

        // initialize the indicatorsList array
        indicators = new Indicator[indicatorsList.length];

        // main filling loop
        for(int c = 0; c < indicators.length; c++ ) {
            //
            indicators[c] = IndicatorList.getInstanceByCodeName(indicatorsList[c].getCodeName(),
                                                                indicatorParameters[c] );

        } // end of for loop

    } // end of method initIndicators()

    
    /**
     * Sets the lastStandingOrder member.
     * 
     * @param order The last standing order generated by this market analyzer. If null is provided to this
     *              argument the lastStandingOrder member will be set to null.
     */
    private void setLastStandingOrder(StandingOrder order) {
        lastStandingOrder = order;
    } // end of method setLastStandingOrder()


    /**
     * Returns the lastStandingOrder member.
     *
     * @return The last standing order generated by this market analyzer. If  standing order was never generated or
     * the last generated one has been closed, the method will return null.
     */
    public StandingOrder getLastStandingOrder() {
        return lastStandingOrder;
    } // end of method getLastStandingOrder()


    /** 
     * Sets the lastFinancialResult member.
     * 
     * @param fResult The financial result produced by closing the last standing order. If null is provided
     *                to this argument error will be generated.
     */
    private void setLastFinancialResult(BigDecimal fResult) {
        // check for null pointer
        if(fResult == null) {
            // error ...
            eHandler.newError(ErrorType.NULL_ARGUMENT, "setLastFinancialResult");

            // set the default value
            lastFinancialResult = BigDecimal.ZERO;

            // exit from method
            return;
        } // end of if statement

        // set the lastFinancialResult
        lastFinancialResult = fResult;

    } // end of method setFinancialResult()


    /**
     * Returns the lastFinancialResult member and than sets it to null.
     *
     * @return Non null signed BigDecimal representing the lastFinancialResult.
     */
    public BigDecimal getLastFinancialResult() {
        // declare local variables:
        BigDecimal result = lastFinancialResult;
        // end of local variables declaration


        //
        lastFinancialResult = null;

        // return the result
        return result;

    } // end of method getLastFinancialResult()


    /**
     * Core analyzing method used for performing technical analysis of the market. The analysis is based on
     * the information contained in the rawData member and thus the rawData must be updated with latest data before
     * calling this method. The non raw types of market data ( all of which  are derivatives of the raw data )
     * are updated in this method. If the AnalysisResult produced by this method is standing order, it will be
     * stored in the lastStandingOrder member. If there is existing last standing order this method will check
     * if it should remain open. If it should be closed this method will close it and than proceed
     * to analyze the market. If the existing last standing order is not closed this method wil exit without doing
     * anything with deafult NO_ACTION result.
     *
     * @param data Instance of the MarketRawData class containing up to date information about the
     *             market conditions. Providing null to this argument will generate error.
     */
    public AnalysisResult analyzeMarket(MarketRawData data) {
        // declare local variables:
        AnalysisResult result = new AnalysisResult();   // the result to be returned by this method
        StandingOrder newGeneratedStandingOrder;                 // new standing order generated by this method in the current method call
        BigDecimal standingOrderPrice;                  // the open price of the new standing order
        boolean closedStandingOrder = false;            // shows if the last standing order was closed
        // end of local variables declaration


        // update all financial data
        setFinancialData(data);

        //
        updateFinancialStatus();

        // check if there is an active standing order
        if(lastStandingOrder != null) {
            return result;
        } // end of if statement

        // check if the specifiedIndicators array is not empty
        if(indicators != null) {
            //,,,
        } // end of if statement

        // produce the final analysis result
        result = useSpecifiedFormat();

        // check if the produced analysis result is standing order
        if(StandingOrder.isStandingOrder(result) ) {
            // determine the the price at which the standing order is opened
            if(result.getTradeAction() == TradeAction.OPEN_LONG_POS) {
                standingOrderPrice = rawData.getNonArrayData().getBuyPrice();
            } else {
                standingOrderPrice = rawData.getNonArrayData().getSellPrice();
            } // end of if statement

            // construct the standing order buffer
            newGeneratedStandingOrder = new StandingOrder( result.getTradeAction() , standingOrderPrice ,
                                              result.getStopLoss() , result.getTakeProfit() );
            // set the standing order
            setLastStandingOrder(newGeneratedStandingOrder);

            // set the newStandingOrder member to true
            setNewStandingOrder(true);

            // exit from method
            return result;

        } // end of if statement

        // return the result
        return result;

    } // end of method generateIndicatorData()


    /**
     * Invokes the specified analysis.
     *
     * @return The result produced by analysis.
     */
    private AnalysisResult useSpecifiedFormat() {
        // declare local variables:
        AnalysisResult result = new AnalysisResult();
        // end of local variables declaration


        //
        switch(analysisFormat.getAnalysisOptions()[0] ) {
            case ALWAYS_OPEN_LONG:
                result = alwaysOpen(TradeAction.OPEN_LONG_POS);
            break;

            case ALWAYS_OPEN_SHORT:
                result = alwaysOpen(TradeAction.OPEN_SHORT_POS);
            break;

            case BASIC_ANALYSIS:
                result = basicAnalysis();
            break;

            case STANDART:
                result = standartAnalysis();
            break;

        } // end of switch statement

        // return the result
        return result;

    } // end of method


    /**
     *
     */
    private AnalysisResult basicAnalysis() {
        // declare local variables:
        AnalysisResult result = new AnalysisResult();
        MovingAverage sma;
        BasicInterval basicIntervals[];
        // end of local variables declaration


        // get the sma
        sma = intervalData.getCloseInterval().generateSimpleMovingAverage(5);
        
        // get the basicIntervals
        basicIntervals = sma.getBasicIntervals();
        
        // check for long
        if(basicIntervals[basicIntervals.length - 1].getDirection() == Direction.UP) {
            //
            result = new AnalysisResult(TradeAction.OPEN_LONG_POS ,
                                        generator.calculateMinStopLoss(StopLevelGenerator.
                                        TradePositionType.LONG, rawData) ,
                                        generator.calculateMinTakeProfit(StopLevelGenerator.
                                        TradePositionType.LONG, rawData) );
            // exit from method
            return result;

        } // end of if statement

        /* check for short
        if(basicIntervals[basicIntervals.length - 1].getDirection() == Direction.DOWN) {
            //
            result = new AnalysisResult(TradeAction.OPEN_SHORT_POS ,
                                        generator.calculateMinStopLoss(StopLevelGenerator.
                                        TradePositionType.SHORT, rawData) ,
                                        generator.calculateMinTakeProfit(StopLevelGenerator.
                                        TradePositionType.SHORT, rawData) );
            // exit from method
            return result;

        } // end of if statement */
        
        // return the result
        return result;

    } // end of method basicAnalysis()
    

    /**
     *
     * @param action
     * @return
     */
    private AnalysisResult alwaysOpen(TradeAction action) {
        // declare local variables:
        AnalysisResult result = null;
        // end of local variables declaration


        //
        switch(action) {
            case OPEN_LONG_POS:
                result = new AnalysisResult(TradeAction.OPEN_LONG_POS ,
                                            generator.calculateMinStopLoss(StopLevelGenerator.
                                            TradePositionType.LONG, rawData) ,
                                            generator.calculateMinTakeProfit(StopLevelGenerator.
                                            TradePositionType.LONG, rawData) );
            break;

            case OPEN_SHORT_POS:
                result = new AnalysisResult(TradeAction.OPEN_SHORT_POS ,
                                            generator.calculateMinStopLoss(StopLevelGenerator.
                                            TradePositionType.SHORT, rawData) ,
                                            generator.calculateMinTakeProfit(StopLevelGenerator.
                                            TradePositionType.SHORT, rawData) );
            break;

        } // end of switch statement

        // return the result
        return result;

    } // end of method alwaysOpen



    /**
     *
     * @param data The new NonArrayData.
     */
    public void updateNonArrayData(NonArrayData data) {
        // update the non array data
        rawData.updateNonArrayData(data);

        // update the last standing order and the last financial result status
        updateFinancialStatus();

    } // end of method updateNonArrayData


    /**
     *
     */
    private void updateFinancialStatus() {

        // check if there is non closed standing order
        if(getLastStandingOrder() != null) {

            // there is active standing order. call its checkIfShouldBeClosed method to determine if
            // it should be closed
            lastStandingOrder.checkIfShouldBeClosed(rawData);

            // check if the last standing order should be discarded
            if(lastStandingOrder.isClosed() ) {
                // store the financial result produced by the last standing order
                setLastFinancialResult(lastStandingOrder.getFinancialResult() );

                // set the lastClosedStandingOrder member
                setLastClosedStandingOrder(lastStandingOrder);

                // lastStandingOrder is closed and no longer needed; discard it
                setLastStandingOrder(null);

            } // end of if statement


        } // end of if statement

    } // end of method updateFinancialStatus()


    /**
     *
     * @return
     */
    private AnalysisResult standartAnalysis() {
        // declare local variables:
        AnalysisResult result = new AnalysisResult();
        MovingAverage sma;
        Trend lastTrend;
        // end of local variables declaration


        // get the sma
        sma = intervalData.getCloseInterval().generateSimpleMovingAverage(5);

        // get the lastTrend
        lastTrend = Trend.getLastTrendInInterval(sma);

        // check for long position
        if(lastTrend.getDirection() == Direction.UP) {
            if(lastTrend.getLenght() > 4) {
                // request long position
                result = new AnalysisResult(TradeAction.OPEN_LONG_POS ,
                                            generator.calculateMinStopLoss(StopLevelGenerator.
                                            TradePositionType.LONG, rawData) ,
                                            generator.calculateMinTakeProfit(StopLevelGenerator.
                                            TradePositionType.LONG, rawData) );

            } // end of if statement

        } // end of if statement

        /*// check for short position
        if(lastTrend.getDirection() == Direction.DOWN) {
            if(lastTrend.getLenght() > 4) {
                // request long position
                result = new AnalysisResult(TradeAction.OPEN_SHORT_POS ,
                                            generator.calculateMinStopLoss(StopLevelGenerator.
                                            TradePositionType.SHORT, rawData) ,
                                            generator.calculateMinTakeProfit(StopLevelGenerator.
                                            TradePositionType.SHORT, rawData) );

            } // end of if statement

        } // end of if statement*/

        // return the result
        return result;

    } // end of method



} // end of class MarketAnalyzer
